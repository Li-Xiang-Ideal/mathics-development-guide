Glossary of Low-level Concepts in Mathics Design
================================================


Verbs
-----

* Rewrite: is an operation over an Expression that produces a new Expression by reorganizing the head and the leaves of an expression and its subexpressions without information of the ``Definition`` s associated with the expression. Operations like ``Flatten``, ``Thread``, ``Sort``, ``Apply``, ``Part`` and ``Drop`` in WL are examples of this kind of operation.

* Apply: Given a ``Rule``, and an ``Expression``, to ``apply`` the rule to the expression (in WL, ``Replace``) consists of looking into the Expression for subexpressions that matches a Pattern, and creating a new expression where the matched subexpressions are replaced by the replace element of the Rule. In the case of BuiltinRules, instead of using a fixed replace the expression, the new expression is generated by a call to a Python function (see Rules).

* Evaluate: Evaluate is an action that involves an ``Expression`` and an  ``Evaluation`` object. This action consists of applying transformation rules associated with the definition of the Symbols forming the expression recursively (going over increasingly deeper levels of leaves in the expression) and iteratively until no new rules can be applied successfully to produce a new expression.



Expressions
-----------

* BaseExpression (Literals?): Is a "virtual" base class for objects representing a "Literal" mathematical expression, like ``2``, ``a+b``, ``F[x,y]``, or more sophisticated structures like Graphics, Streams, Sounds, etc.

* ``Atoms``: Literals that should be treated in evaluations as a whole thing. For example, Numbers and strings are ("Raw", according to [WL reference]) atoms,
but also `Symbol` (which can be evaluated, but do not have parts) or  `Image` and `Dispatch` objects (for which we can ask for a "Part") are.

* ``Symbol`` s: is a type of Atom characterized by a name, that can be evaluated. Inside a session, a Symbol has associated with a ``Definition`` that defines how the symbol is going to be evaluated alone or as a part of an Expression.

* ``Expression`` s: An ``Expression`` has a ``Head`` and "leaves". Both the ``Head`` and all the leaves of the expression are also some kind of literal.  If the ``Head`` of the expression is a ``Symbol``, it represents the "lookup-symbol" of the expression. This symbol controls, through its associated definition, how the expression is going to be evaluated, like which leaves should be evaluated and which basic reformatting procedures should be applied to the expression before the expression as a whole as well as how to do that evaluation. If the Head is also an ``Expression``, the lookup symbol is the lookup symbol of the head.

* ``SubExpression`` s: Represents a reference to a part of an ``Expression``. 

  
Rules
-----

* ``Pattern``s: A pattern represents an object that can match with an ``Expression`` or a part of the ``Expression``.  For example, ``F[x_Symbol]`` is a pattern.

* (Replacement) ``Rule`` s: Consists of a ``Pattern`` and replace. Rules can be **applied** to an ``Expression`` to produce a new ``Expression``. For example ``F[x_Real]-> x^2``
is a rule that when applied to the expression ``G[F[1.], F[a]]`` produces the new expression ``G[1.^2, F[a]]``. Certain (internal) rules can also produce changes in the state of the system (writing files, printing a string, changing the definitions of a symbol, or setting a timeout). This happens for internal rules, like the associated to the pattern `Set[a,1.]`, which modifies the definition of `a` adding the rule `a->1.` (seel below).

There are two kinds of rules,

* (WL) ``Rule`` s and ``BuiltinRule`` s. In a (WL) Rule, the replace is defined in terms of a new expression. If the ``Pattern`` contains "named subpatterns" (i.e., the ``Pattern`` has leaves which are of the form ``Pattern[symbol, pat]``) symbols in the replace expressions that match with the symbol in one subpattern are replaced by the corresponding subexpressions. For example,  in we apply the rule  ``F[x_]->x^2`` to the expression `G[F[1.], F[a]]` we get ``G[1.^2, a^2]``. Applying this kind of rule can not affect the state of the system.

* ``BuiltinRule`` s, on the other hand, have associated a Python function. Each time the Pattern matches a part of the expression, the expression is replaced by the result of calling that function, with parameters given by the name of the symbols in the named subpatterns. For example, the symbol ``System`Plus`` has associated a BuiltinRule
``Plus[items___]->mathics.builtin.arithfns.basic.Plus.apply``. When applied to the expression `F[a+a]` the method ``mathics.builtin.arithfns.basic.Plus.apply`` is called
passing a parameter  `items` with a value `Sequence[a,a]`. The return value of this function is ``Times[2, a]``  (``2*a``), which is replaced in the original expression resulting in ``F[2*a]``. Notice that these kinds of rules can also change the state of the system. For example, the rule ``SetAttributes[a_,b_]->mathics.builtin.attributes.SetAttributes.apply``, when applied to the expression  ``SetAttributes[F, NumericFunction]`` sets the attribute ``NumericFunction`` in the definition of the symbol ``F`` and returns ``SymbolNull``. 

In any case, if the ``Rule`` fails to be applied to the ``Expression``, ``apply`` returns ``None``. 



Definition
----------

A ``Definition`` is a collection of ``Rule``s and attributes associated to a given `Symbol`. The ``Rule``s are internally organized in terms of the context of application in
`ownvalues`, `upvalues`,  `downvalues`,  `subvalues`, `nvalues`,  `format`, etc. 

Definitions
-----------

The state of one instance of the Mathics interpreter (independently of the Front-End choose) is stored in this object. The state is then stored as ``Definition`` object of the different symbols defined during the runtime. In the current implementation, the ``Definitions`` object stores ``Definition`` s in four dictionaries:
- builtins: stores the defintions of the ``Builtin`` symbols
- pymathics: stores the definitions of the ``Builtin`` symbols added from pymathics modules.
- user: stores the definitions created during the runtime.
- definition_cache: keep definitions obtained by merging builtins, pymathics, and user definitions associated to the same symbol.


Evaluation
----------

``Evaluation`` object represents the evaluation of a complete expression. This object stores several variables relevant to such evaluation, like a reference to the ``Definitions`` object of the session, timeout times, and expected formats.
The object has a `evaluate` method, that starting from an ``S-Expression`` produces a ``Result`` object, that holds the result of the evaluation, including the resulting ``Expression``, a fully formatted string representation of that result, and a line number. Also handles all the unhandled interruptions raised during the evaluation.
The ``Evaluation``  object also implements methods like ``print_out``, ``message``, ``error``, and other related methods, that control how messages (warnings, errors, and general printing) produced during the evaluation are presented.
